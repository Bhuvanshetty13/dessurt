import json
import timeit
import torch
from torch.utils.data import Dataset
from torch.autograd import Variable

from collections import defaultdict
from glob import iglob
import os
import utils.img_f as img_f
import numpy as np
import math, time
import random, string

from utils import grid_distortion

from utils import string_utils, augmentation
from utils.util import ensure_dir
from utils.yolo_tools import allIOU
from .form_qa import FormQA, collate, Entity, Line, Table
from .gen_daemon import GenDaemon


import random, pickle
PADDING_CONSTANT = -1







class SynthFormDataset(FormQA):
    def __init__(self, dirPath, split, config):
        super(SynthFormDataset, self).__init__(dirPath,split,config)
        font_dir = config['font_dir']
        self.gen_daemon = GenDaemon(font_dir)
        self.color=False
        self.image_size = config['image_size'] if 'image_size' in config else None
        if type(self.image_size) is int:
            self.image_size = (self.image_size,self.image_size)
        self.min_text_height = config['min_text_height'] if 'min_text_height' in config else 8
        self.max_text_height = config['max_text_height'] if 'max_text_height' in config else 32
        self.table_prob = config['tables'] if 'tables' in config else 0
        self.match_title_prob = 0.3
        self.match_label_prob = 0.5
        self.blank_value_prob = 0.01
        self.new_col_chance = 0.15
        self.side_by_side_prob = 0.5
        self.min_qa_sep = 10
        self.max_qa_sep = 250
        self.block_pad_max = 500
        with open(os.path.join(dirPath,'gpt2_generation.json')) as f:
            self.documents = json.load(f)
        #READ CSVs TODO

        self.warp_freq = 1.0
        if split=='train':
            self.augmentation = config['augmentation'] if 'augmentation' in config else None
	    

            
        
        self.images=[]
        for i in range(config['batch_size']*100): #we just randomly generate instances on the fly
            self.images.append({'id':'{}'.format(i), 'imagePath':None, 'annotationPath':0, 'rescaled':1.0, 'imageName':'0'})





    def parseAnn(self,annotations,s):
        #This defines the creation of the image with its GT entities, boxes etc.
        #Questions are generated by parent class with maskQuestions()



        image_h,image_w = self.image_size
        image = np.zeros([image_h,image_w],dtype=np.uint8)
        all_entities=[]
        entity_link=[]
        tables=[]

        success=True
        boxes = []
        prev_boxes=[(0,0,image_w,0)]
        furthest_right=0
        while success:
            #pick starting point
            x1,y1,x2,y2 = random.choice(prev_boxes)
            if x1>=furthest_right:
                x2 = image_w
            if random.random()<self.table_prob:
                success,box = self.addTable(x1,y2,x2,image,tables)
                if success:
                    all_entities += tables[-1].allEntities()
            else:
                success,box = self.addForm(x1,y2,x2,image,all_entities,entity_link)
            
            if success:
                prev_box[-1]=box
                if box[3]>furthest_right:
                    furthest_right = box[3]
                prev_boxes.append((furthest_right,0,image_w,0)) #add non-box, just to the right

        assert len(all_entities)>0



        image = np.full((self.image_size[0],self.image_size[1]),255,np.uint8)

        

        
        #run through all entites to build bbs, assign bbid, and find ambiguity
        boxes = []
        text_line_counts = defaultdict(list)
        for ei,entity in enumerate(all_entities):
            for li,line in enumerate(entity.lines):
                text = self.punc_regex.sub('',line.text.lower())
                text_line_counts[text].append((ei,li))
                bbid = len(boxes)
                boxes.append(self.convertBB(s,line.box))
                line.bbid = bbid

        bbs = np.array(boxes)

        #assign ambiguity
        for line_ids in text_line_counts.values():
            if len(line_ids)>1:
                for ei,li in line_ids:
                    all_entities[ei].lines[li].ambiguous = True

        #now set up a full linking dictionary
        link_dict=defaultdict(list)
        for e1,e2s in entity_link:
            if e2s is not None:
                if isinstance(e2s,int):
                    e2s=[e2s]
                link_dict[e1]+=e2s
                for e2 in e2s:
                    link_dict[e2].append(e1)
        #Add all the link for tables
        for table in tables:
            for r,r_header in enumerate(table.row_headers):
                r_index = all_entities.index(r_header)
                for c,c_header in enumerate(table.col_headers):
                    c_index = all_entities.index(c_header)
                    v=table.cells[r][c]
                    if v is not None:
                        v_index = all_entities.index(v)
                        link_dict[r_index].append(v_index)
                        link_dict[c_index].append(v_index)
                        link_dict[v_index].append(r_index)
                        link_dict[v_index].append(c_index)
        link_dict = self.sortLinkDict(all_entities,link_dict)

        qa = self.makeQuestions(s,all_entities,entity_link,tables,all_entities,link_dict)

        return bbs, list(range(bbs.shape[0])), None, {'image':255-image}, {}, qa

    

    def addTable(self,image):
        #TODO
        #Taken from FUNSD_QA
        num_rows=random.randrange(1,15)
        num_cols=random.randrange(1,10)

        mean_height = random.randrange(self.min_text_height+1,self.max_text_height)

        table_entries = random.choices(list(enumerate(self.header_labels)),k=num_rows*num_cols+num_rows+num_cols)
        #table_entries = [(img_f.imread(os.path.join(self.header_dir,'{}.png'.format(e[0]))),e[1]) for e in table_entries]
        table_entries_1d = []
        for num,label in table_entries:
            img = img_f.imread(os.path.join(self.header_dir,'{}.png'.format(num)))
            if self.change_size:
                height = int(random.gauss(mean_height,4))#random.randrange(self.min_text_height,img.shape[0])
                width = round(img.shape[1]*height/img.shape[0])
                if height>1 and width>1:
                    img = img_f.resize(img,(height,width))
            table_entries_1d.append((img,label))
        row_headers = table_entries_1d[-num_rows:]
        col_headers = table_entries_1d[-(num_rows+num_cols):-num_rows]
        table_entries = table_entries_1d[:-(num_rows+num_cols)]
        table_entries_2d = []
        for r in range(num_rows):
            table_entries_2d.append(table_entries_1d[r*num_cols:(r+1)*num_cols])
        table_entries = table_entries_2d


        table_x = random.randrange(self.image_size[1]*0.75)
        table_y = random.randrange(self.image_size[0]*0.75)

        padding = random.randrange(0,30)

        #find the height of each row and cut rows that spill off page
        max_height=0
        for c in range(num_cols):
            max_height = max(max_height,col_headers[c][0].shape[0])
        total_height = max_height+padding
        height_col_heading = max_height+padding
        
        if total_height+table_y >= self.image_size[0]:
            #NO TABLE
            return None,None,None,None, None
        height_row=[0]*num_rows
        for r in range(num_rows):
            max_height = row_headers[r][0].shape[0]
            for c in range(num_cols):
                max_height = max(max_height,table_entries[r][c][0].shape[0])
            height_row[r] = max_height+padding
            total_height+= max_height+padding

            if total_height+table_y >= self.image_size[0]:
                num_rows = r
                if num_rows==0:
                    return None,None,None,None,None #NO TABLE
                total_height -= height_row[r]
                row_headers=row_headers[:num_rows]
                height_row=height_row[:num_rows]
                break

        #find the width of each rowumn and cut rowumns that spill off page
        max_width=0
        for r in range(num_rows):
            max_width = max(max_width,row_headers[r][0].shape[1])
        total_width = max_width+padding
        width_row_heading = max_width+padding
        
        if total_width+table_x >= self.image_size[1]:
            #NO TABLE
            return None,None,None,None, None
        width_col=[0]*num_cols
        for c in range(num_cols):
            max_width = col_headers[c][0].shape[1]
            for r in range(num_rows):
                max_width = max(max_width,table_entries[r][c][0].shape[1])
            width_col[c] = max_width+padding
            total_width+= max_width+padding

            if total_width+table_x >= self.image_size[1]:
                num_cols = c
                if num_cols==0:
                    return None,None,None,None, None#NO TABLE
                total_width -= width_col[c]
                col_headers=col_headers[:num_cols]
                width_col=width_col[:num_cols]
                break
    

        #put row headers in image
        row_headers_e=[]
        cur_y = height_col_heading+table_y
        for r in range(num_rows):
            if width_row_heading-padding==row_headers[r][0].shape[1]:
                x=table_x
            else:
                x=table_x + random.randrange(0,width_row_heading-padding-row_headers[r][0].shape[1])
            if height_row[r]-padding==row_headers[r][0].shape[0]:
                y=cur_y
            else:
                y=cur_y + random.randrange(0,height_row[r]-padding-row_headers[r][0].shape[0])
            cur_y += height_row[r]

            image[y:y+row_headers[r][0].shape[0],x:x+row_headers[r][0].shape[1]] = row_headers[r][0]
            box = [x,y,x+row_headers[r][0].shape[1],y+row_headers[r][0].shape[0]]
            if row_headers[r][1] == '':
                string='-'
            else:
                string=row_headers[r][1]
            row_headers_e.append( Entity('answer',[Line(string,box)]) )
            #if boxes is not None:
            #    self.addText(row_headers[r][1],x,y,row_headers[r][0].shape[1],row_headers[r][0].shape[0],boxes=boxes,trans=trans)

        #put col headers in image
        col_headers_e=[]
        cur_x = width_row_heading+table_x
        for c in range(num_cols):
            if height_col_heading-padding==col_headers[c][0].shape[0]:
                y=table_y
            else:
                y=table_y + random.randrange(0,height_col_heading-padding-col_headers[c][0].shape[0])
            if width_col[c]-padding==col_headers[c][0].shape[1]:
                x=cur_x
            else:
                x=cur_x + random.randrange(0,width_col[c]-padding-col_headers[c][0].shape[1])
            cur_x += width_col[c]

            image[y:y+col_headers[c][0].shape[0],x:x+col_headers[c][0].shape[1]] = col_headers[c][0]
            box = [x,y,x+col_headers[c][0].shape[1],y+col_headers[c][0].shape[0]]
            if col_headers[c][1] == '':
                string='-'
            else:
                string=col_headers[c][1]
            col_headers_e.append( Entity('answer',[Line(string,box)]) )
            #if boxes is not None:
            #    self.addText(col_headers[c][1],x,y,col_headers[c][0].shape[1],col_headers[c][0].shape[0],boxes=boxes,trans=trans)

        table = Table(row_headers_e,col_headers_e)

        #put in entries
        cur_x = width_row_heading+table_x
        for c in range(num_cols):
            cur_y = height_col_heading+table_y
            for r in range(num_rows):
                if random.random()>0.2 and len(table_entries[r][c][1])>0: #sometimes skip an entry
                    if width_col[c]-padding==table_entries[r][c][0].shape[1]:
                        x=cur_x
                    else:
                        x=cur_x + random.randrange(0,width_col[c]-padding-table_entries[r][c][0].shape[1])
                    if height_row[r]-padding==table_entries[r][c][0].shape[0]:
                        y=cur_y
                    else:
                        y=cur_y + random.randrange(0,height_row[r]-padding-table_entries[r][c][0].shape[0])

                    image[y:y+table_entries[r][c][0].shape[0],x:x+table_entries[r][c][0].shape[1]] = table_entries[r][c][0]
                    #table_values.append((col_headers[c][1],row_headers[r][1],table_entries[r][c][1],x,y))
                    box = [x,y,x+table_entries[r][c][0].shape[1],y+table_entries[r][c][0].shape[0]]
                    table.cells[r][c]=Entity('answer',[Line(table_entries[r][c][1],box)])
                    #if boxes is not None:
                    #    self.addText(table_entries[r][c][1],x,y,table_entries[r][c][0].shape[1],table_entries[r][c][0].shape[0],boxes=boxes,trans=trans)
                
                cur_y += height_row[r]
            cur_x += width_col[c]

        #add lines for headers
        line_thickness_h = random.randrange(1,max(2,min(10,padding)))
        #top
        img_f.line(image,
                (max(0,table_x+random.randrange(-5,5)),table_y+height_col_heading-random.randrange(0,1+padding)),
                (min(self.image_size[1]-1,table_x+total_width+random.randrange(-5,5)),table_y+height_col_heading-random.randrange(0,1+padding)),
                random.randrange(0,100),
                line_thickness_h
                )
        #side
        img_f.line(image,
                (table_x+width_row_heading-random.randrange(0,padding+1),max(0,table_y+random.randrange(-5,5))),
                (table_x+width_row_heading-random.randrange(0,padding+1),min(self.image_size[0]-1,table_y+total_height+random.randrange(-5,5))),
                random.randrange(0,100),
                line_thickness_h
                )

        #outside of headers?
        if random.random()<0.5:
            line_thickness = random.randrange(1,max(2,min(10,padding)))
            #top
            img_f.line(image,
                    (max(0,table_x+random.randrange(-5,5)),table_y-random.randrange(0,padding+1)),
                    (min(self.image_size[1]-1,table_x+total_width+random.randrange(-5,5)),table_y-random.randrange(0,padding+1)),
                    random.randrange(0,100),
                    line_thickness
                    )
            #side
            img_f.line(image,
                    (table_x-random.randrange(0,padding+1),max(0,table_y+random.randrange(-5,5))),
                    (table_x-random.randrange(0,padding+1),min(self.image_size[0]-1,table_y+total_height+random.randrange(-5,5))),
                    random.randrange(0,100),
                    line_thickness
                    )

        #value outline?
        if random.random()<0.5:
            line_thickness = random.randrange(1,max(2,min(10,padding)))
            #bot
            img_f.line(image,
                    (max(0,table_x+random.randrange(-5,5)),table_y-random.randrange(0,padding+1)+total_height),
                    (min(self.image_size[1]-1,table_x+total_width+random.randrange(-5,5)),table_y-random.randrange(0,padding+1)+total_height),
                    random.randrange(0,100),
                    line_thickness
                    )
            #right
            img_f.line(image,
                    (table_x-random.randrange(0,padding+1)+total_width,max(0,table_y+random.randrange(-5,5))),
                    (table_x-random.randrange(0,padding+1)+total_width,min(self.image_size[0]-1,table_y+total_height+random.randrange(-5,5))),
                    random.randrange(0,100),
                    line_thickness
                    )

        #all inbetween lines?
        if random.random()<0.5:
            line_thickness = random.randrange(1,max(2,line_thickness_h))
            #horz
            cur_height = height_col_heading
            for r in range(num_rows-1):
                cur_height += height_row[r]
                img_f.line(image,
                        (max(0,table_x+random.randrange(-5,5)),table_y-random.randrange(0,padding+1)+cur_height),
                        (min(self.image_size[1]-1,table_x+total_width+random.randrange(-5,5)),table_y-random.randrange(0,padding+1)+cur_height),
                        random.randrange(0,100),
                        line_thickness
                        )
            #right
            cur_width = width_row_heading
            for c in range(num_cols-1):
                cur_width += width_col[c]
                img_f.line(image,
                        (table_x-random.randrange(0,padding+1)+cur_width,max(0,table_y+random.randrange(-5,5))),
                        (table_x-random.randrange(0,padding+1)+cur_width,min(self.image_size[0]-1,table_y+total_height+random.randrange(-5,5))),
                        random.randrange(0,100),
                        line_thickness
                        )

        
        #now, optionally add the other lines
        #TODO?
        
        return table_x-10, table_y-10, total_width+20, total_height+20, table

    def addForm(self,init_x,init_y,max_x,image,entities,entity_link):
        title,pairs = random.choice(self.documents)

        max_y = image.shape[0]
        label_matches_title = random.random()<self.match_title_prob and title is not None
        value_matches_label = random.random()<self.match_label_prob

        
        label_height = None

        #generate text images
        if title is not None:
            title_words,title_font = self.gen_daemon.generate(title,ret_font=True) #(text,img)
        if label_matches_title:
            label_font = title_font
        else:
            label_font = None
        if value_matches_label:
            value_font = label_font
        else:
            value_font = None
        options=['colon','line','line+colon','dotted line','dotted line+colon','box','box+colon','none']
        cue = random.choice(options)
        image_pairs = []
        for label,value in pairs:
            label_words,label_font = self.gen_daemon.generate(label+(':' if 'colon' in cue else ''),font=label_font,ret_font=True)
            if random.random()<self.blank_value_prob:
                value_words = []
            elif isinstance(value,str):
                value_words,value_font = self.gen_daemon.generate(value,font=value_font,ret_font=True)
                value_words = [value_words]
            else:
                #list answer
                list_values=[]
                for value_item in value:
                    value_words,value_font = self.gen_daemon.generate(value,font=value_font,ret_font=True)
                    list_values.append(value_words)
                value_words = list_values
            image_pairs.append((label_words,value_words))
        
        start_x = init_x+self.block_pad_max
        start_y = init_y+self.block_pad_max
        title_height = self.max_text_height
        label_height = self.max_text_height
        value_height = self.max_text_height
        num_pairs = len(pairs)
        for retry in range(5):

            start_x = random.randrange(init_x+1,start_x)
            start_y = random.randrange(init_y+1,start_y)
            
            #setup text height and spacing
            if title is not None:
                title_height = random.randrange(self.min_text_height,1+title_height)
            em_approx = title_height*1.6 #https://en.wikipedia.org/wiki/Em_(typography)
            min_space = 0.2*em_approx #https://docs.microsoft.com/en-us/typography/develop/chara  cter-design-standards/whitespace
            max_space = 0.5*em_approx
            title_space_width = round(random.random()*(max_space-min_space) + min_space)
            title_newline_height = random.randrange(1,title_height) + title_height

            if label_matches_title:
                label_height = title_height
            else:
                label_height = random.randrange(self.min_text_height,1+min(label_height,title_height))
            em_approx = label_height*1.6 #https://en.wikipedia.org/wiki/Em_(typography)
            min_space = 0.2*em_approx #https://docs.microsoft.com/en-us/typography/develop/chara  cter-design-standards/whitespace
            max_space = 0.5*em_approx
            label_space_width = round(random.random()*(max_space-min_space) + min_space)
            label_newline_height = random.randrange(1,label_height) + label_height

            if value_matches_label:
                value_height = label_height
            else:
                value_height = random.randrange(self.min_text_height,1+min(value_height,title_height))
            em_approx = value_height*1.6 #https://en.wikipedia.org/wiki/Em_(typography)
            min_space = 0.2*em_approx #https://docs.microsoft.com/en-us/typography/develop/chara  cter-design-standards/whitespace
            max_space = 0.5*em_approx
            value_space_width = round(random.random()*(max_space-min_space) + min_space)
            value_newline_height = random.randrange(1,value_height) + value_height
            value_list_newline_height = value_newline_height + value_newline_height*random.random()
            
            max_word_width = 0
            if title is not None:
                title_word_ws = [round(img.shape[1]*(title_height/img.shape[0])) for text,img in title_words]
                max_word_width = max(title_word_ws)
            
            w_pairs = []
            max_value_word_w=max_label_word_w=0
            for label_words,value_words in image_pairs:
                label_word_ws = [round(img.shape[1]*(label_height/img.shape[0])) for text,img in label_words]
                max_label_word_w = max(max_label_word_w,*label_word_ws)
                value_word_ws = []
                for value_words_item in value_words:
                    value_word_ws_item = [round(img.shape[1]*(value_height/img.shape[0])) for text,img in value_words_item]
                    max_word_width = max(max_word_width,*label_word_ws,*value_word_ws_item)
                    max_value_word_w = max(max_value_word_w,*value_word_ws_item)
                    value_word_ws.append(value_word_ws_item)

                w_pairs.append((label_word_ws,value_word_ws))

            block_width = max_x-start_x
            if max_word_width>block_width:
                continue #retry, we need to shrink things


            #how wide will the title be?
            if title is not None:
                max_title_width = random.randrange(max(title_word_ws),int(block_width*0.66))
                max_title_x = start_x+max_title_width
                #layout the title to see how tall it is
                title_str=''
                title_str_lines=[]
                title_img_pos_lines=[]
                title_img_pos=[]
                cur_x=start_x
                rightmost_title_x=cur_x
                for title_w, (title_text,title_img) in zip(title_word_ws,title_words):
                    if cur_x+title_w>max_title_x:
                        #newline
                        title_str_lines.append(title_str)
                        title_str=''
                        title_img_pos_lines.append(title_img_pos)
                        title_img_pos=[]
                        cur_x = col_x
                        cur_y += title_newline_height
                        if cur_y+title_height>max_y:
                            continue
                    elif len(title_str)>0:
                        title_str+=' '#space
                    title_x = cur_x
                    title_y = cur_y
                    
                    cur_x+=title_w+title_space_width
                    title_str += title_text
                    title_img_pos.append((title_x,title_y,title_img,title_height,title_w))
                    rightmost_title_x = max(rightmost_title_x,title_x+title_w)
            else:
                end_title_y=start_y


            can_do_side_by_side = max_value_word_w+max_label_word_w+self.min_qa_sep < block_width
            
            side_by_side = can_do_side_by_side and random.random()<self.side_by_side_prob
            if side_by_side:
                aligned_cols = random.random()<0.5 or cue=='none'
            else:
                aligned_cols = False
                print('WARNING, non-side-by-side not implmented!!')
            if aligned_cols:
                value_width = random.randrange(max_value_word_w,(block_width)-(max_label_word_w+self.min_qa_sep))
                label_width = random.randrange(max_label_word_w,(block_width)-(value_width+self.min_qa_sep))
                sep = (block_width)-(value_width+label_width)
                if sep>self.min_qa_sep:
                    sep = random.randrange(self.min_qa_sep,min(sep,self.max_qa_sep))
                all_value_x = start_x+label_width+sep
                max_label_x = start_x+label_width
            else:
                sep = random.randrange(self.min_qa_sep,min(self.max_qa_sep,(block_width)-(max_label_word_w+max_value_word_w)))
                max_label_x = max_x-(max_value_word_w+sep)

            cur_x = start_x
            col_x = start_x
            cur_y = end_title_y
            rightmost_x_so_far = cur_x
            max_value_len=0
            import pdb;pdb.set_trace()
            for (label_words,value_words),(label_word_ws_list,value_word_ws_list) in zip(image_pairs,w_pairs):
                cannot_do_pair = False
                restart=True
                while restart: #for restarting as new column
                    restart=False
                    label_str=''
                    label_str_lines=[]
                    label_img_pos=[]
                    label_img_pos_lines=[]
                    for label_w,(label_text,label_img) in zip(label_word_ws,label_words):
                        if cur_x+label_w>max_label_x:
                            #newline
                            label_str_lines.append(label_str)
                            label_str=''
                            label_img_pos_lines.append(label_img_pos)
                            label_img_pos=[]
                            cur_x = col_x
                            cur_y += label_newline_height
                            if cur_y+label_height>max_y:
                                #do we have room for another column?
                                if (aligned_cols and cur_x+sep+2*(label_width+sep+value_width)<max_x) or (not aligned_cols and cur_x+sep+rightmost_x_so_far+max_label_word_w+sep+max_value_word_w):
                                    if aligned_cols:
                                        col_x += label_width+2*sep+value_width
                                        cur_x = col_x
                                        all_value_x += label_width+sep+value_width
                                        max_label_x += label_width+sep+value_width
                                        cur_y = end_title_y
                                    else:
                                        col_x += rightmost_x_so_far+2*sep
                                        cur_x = col_x
                                        max_label_x += rightmost_x_so_far
                                        cur_y = end_title_y
                                    restart = True
                                    break
                                else:
                                    cannot_do_pair=True
                                    break
                        elif len(label_str)>0:
                            label_str+=' '#space
                        label_x = cur_x
                        label_y = cur_y
                        
                        cur_x+=label_w+label_space_width
                        label_str += label_text
                        label_img_pos.append((label_x,label_y,label_img,label_height,label_w))
                        rightmost_x_so_far = max(rightmost_x_so_far,label_x+label_w)

                    if cannot_do_pair:
                        break
                    
                    if len(label_img_pos)>0:
                        label_str_lines.append(label_str)
                        label_img_pos_lines.append(label_img_pos)

                    if aligned_cols:
                        value_start_x = all_value_x
                    else:
                        value_start_x += sep
                    cur_y = random.randrange(min(label_y,label_y+label_height-value_height)-4,max(label_y+value_height,label_y+label_height)+4)
                    max_value_x = max_x
                    value_entities=[]
                    for value_word_ws,value_words in zip(value_word_ws_list,value_words_list):
                        cur_x = value_start_x
                        value_str=''
                        value_str_lines_item=[]
                        value_img_pos_lines_item=[]
                        for value_w,(value_text,value_img) in zip(value_word_ws,value_words):

                            
                            if cur_x+value_w>max_value_x:
                                #newline
                                value_str_lines_item.append(value_str)
                                value_str=''
                                value_img_pos_lines_item.append(value_img_pos)
                                value_img_pos=[]
                                cur_x = value_start_x
                                cur_y += value_newline_height

                                room_for_new_col = (aligned_cols and cur_x+sep+2*(label_width+sep+value_width)<max_x) or (not aligned_cols and cur_x+sep+rightmost_x_so_far+max_label_word_w+sep+max_value_word_w)
                                if cur_y+value_height>max_y or (room_for_new_col and random.random()<self.new_col_chance):
                                    #do we have room for another column?
                                    if room_for_new_col:
                                        if aligned_cols:
                                            col_x += label_width+2*sep+value_width
                                            cur_x = col_x
                                            all_value_x += label_width+sep+value_width
                                            max_value_x += label_width+sep+value_width
                                            cur_y = end_title_y
                                        else:
                                            col_x += rightmost_x_so_far+2*sep
                                            cur_x = col_x
                                            max_value_x += rightmost_x_so_far
                                            cur_y = end_title_y
                                        restart = True
                                        break
                                    else:
                                        cannot_do_pair=True
                                        break
                            elif len(value_str)>0:
                                value_str+=' '#space
                            value_x = cur_x
                            value_y = cur_y
                            
                            cur_x+=value_w+value_space_width
                            value_str += value_text
                            value_img_pos.append((value_x,value_y,value_img,value_height,value_w))

                            rightmost_x_so_far = max(rightmost_x_so_far,value_x+value_w)

                        if cannot_do_pair or restart:
                            break
                        if len(value_img_pos)>0:
                            value_str_lines_item.append(value_str)
                            value_img_pos_lines_item.append(value_img_pos)
                        value_entities.append((value_str_lines_item,value_img_pos_lines_item))
                        righmost_x=0
                        for value_img_pos in value_img_pos_lines_item:
                            righmost_x= max(value_img_pos[0]+value_img_pos[-1],righmost_x)
                        max_value_len = max(max_value_len,rightmost_x-value_start_x)

                        cur_y += value_list_newline_height

                    if cannot_do_pair or restart:
                        break

                    
                    #else add the info to be drawn
                    pairs_to_draw.append((label_str_lines,label_img_pos_lines,value_entities))

                        
                if cannot_do_pair:
                    break

                
            if len(pairs_to_draw)==0:
                #couldn't add this document
                continue #retry



            #place the header
            actual_block_width = max(rightmost_x_so_far,rightmost_title_x)-start_x
            title_width = rightmost_title_x-start_x
            wiggle = min(100,actual_block_width-title_width)
            if title is not None:
                if random.random()<0.5:
                    #left
                    title_x_offset = random.randrange(wiggle)
                else:
                    #middle
                    title_x_offset = (actual_block_width/2)-(title_width/2) + random.randrange(-wiggle//2,wiggle//2)
                #update title position
                for title_img_pos in title_img_pos_lines:
                    for i in range(len(title_img_pos)):
                        x,y,img,h,w = title_img_pos[i]
                        title_img_pos[i] = (x+title_x_offset,y,img,h,w)

            #draw and and the entities + links
            title_entitiy = makeAndDrawEntity(image,'header',title_str_lines,title_img_pos_lines)
            title_ei = len(entities)
            entities.append(title_entity)

            for label_str_lines,label_img_pos_lines,value_entities in pairs_to_draw:
                label_entitiy = makeAndDrawEntity(image,'question',label_str_lines,label_img_pos_lines)
                label_ei=len(entities)
                entities.append(label_entity)
                entity_link.append((title_ei,label_ei))
                

                for value_str_lines,value_img_pos_lines in value_entities:
                    value_entitiy = makeAndDrawEntity(image,'answer',value_str_lines,value_img_pos_lines,max_value_len,cue)
                    value_ei=len(entities)
                    entities.append(value_entity)
                    entity_link.append((label_ei,value_ei))
                
                #if len(value_entities)==0: #blank
                #TODO draw empty line


            return True,(init_x,init_y,start_x+max(rightmost_title_x,rightmost_x_so_far)+start_x+lowest_y)
        return False,None


    def makeAndDrawEntity(self,image,cls,str_lines,img_pos_lines,max_line_length=None,cue=None):
        lines=[]
        if cue is not None and any(prompt in cue for prompt in ['box','line']):
            if random.random()<0.4:
                length = max_line_length
            elif random.random()<0.6:
                length = 0
                for x,y,img,img_h,img_w in img_pos_lines:
                    length=max(length,img_w)
            else:
                length=None
        max_x=max_y = 0
        min_x=min_y = 9999999999999999999
        for text,(x,y,img,img_h,img_w) in zip(str_lines,img_pos_lines):
            img = img_f.resize(img,(img_h,img_w))
            image[y:y+title_height,x:x+img_w] = img
            lines.append(line(text,(x,y,x+img_w,y+title_height)))

            if cue is not None:
                line_thickness = random.random(1,5)
                pad_w = random.randrange(1,5)
                pad_h = random.randrange(1,5)
                color = random.randrange(1,170)
                this_length = length if length is not None else img_w
                dotting = random.randrange(1,5)
                if 'dotted line' in cue:
                    for x in range(x-pad_w,x+this_length+pad_w):
                        if math.sin(x*math.pi/dotting)>0:
                            image[y+img_h+pad_h-line_thickness//2:1+y+img_h+pad_h+line_thickness//2,x]=color

                elif 'line' in cue:
                    img_f.line(image,(x-pad_w,y+img_h+pad_h),(x+this_length+pad_w,y+img_h+pad_h),color,line_thickness)
                elif 'box' in cue:
                    min_x = min(x-pad_w,min_x)
                    min_y = min(y_pad_h,min_y)
                    max_x = max(x+this_length+padw,max_x)
                    max_y = max(y+img_h+pad_h,max_y)
        if cue is not None and 'box' in cue:
            img_f.rectangle(image,(x-pad_w,y_pad_h),(x+this_length+padw,y+img_h+pad_h),color,line_thickness)
        return Entity(cls,lines)
